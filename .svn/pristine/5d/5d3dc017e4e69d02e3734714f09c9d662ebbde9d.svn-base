package spec.benchmarks.xml.transform;//#GEN#[1]#PJ#
//#GEN#[1]#PJ#
import pj.parser.ast.visitor.DummyClassToDetermineVariableType;//#GEN#[1]#PJ#
import pt.runtime.*;//#GEN#[1]#PJ#
import pj.Pyjama;//#GEN#[1]#PJ#
import pj.PJPackageOnly;//#GEN#[1]#PJ#
import pj.UniqueThreadIdGeneratorForOpenMP;//#GEN#[1]#PJ#
import pi.ParIteratorFactory;//#GEN#[1]#PJ#
import pi.ParIterator;//#GEN#[1]#PJ#
import pi.reductions.Reducible;//#GEN#[1]#PJ#
import pi.reductions.Reduction;//#GEN#[1]#PJ#
import java.util.concurrent.atomic.*;//#GEN#[1]#PJ#
import java.util.concurrent.*;//#GEN#[1]#PJ#
import java.awt.EventQueue;//#GEN#[1]#PJ#
import java.util.concurrent.ExecutorService;//#GEN#[1]#PJ#
import java.util.concurrent.Executors;//#GEN#[1]#PJ#
import java.util.concurrent.TimeUnit;//#GEN#[1]#PJ#
import javax.swing.SwingUtilities;//#GEN#[1]#PJ#
import pj.parser.ast.visitor.DummyClassToDetermineVariableType;//#GEN#[3]#PJ#
import pj.*;//#GEN#[4]#PJ#
import java.io.File;//#GEN#[5]#PJ#
import java.io.FileInputStream;//#GEN#[6]#PJ#
import java.io.IOException;//#GEN#[7]#PJ#
import javax.xml.parsers.ParserConfigurationException;//#GEN#[8]#PJ#
import javax.xml.transform.Source;//#GEN#[9]#PJ#
import javax.xml.transform.Templates;//#GEN#[10]#PJ#
import javax.xml.transform.Transformer;//#GEN#[11]#PJ#
import javax.xml.transform.TransformerConfigurationException;//#GEN#[12]#PJ#
import javax.xml.transform.TransformerException;//#GEN#[13]#PJ#
import javax.xml.transform.TransformerFactory;//#GEN#[14]#PJ#
import javax.xml.transform.stream.StreamResult;//#GEN#[15]#PJ#
import javax.xml.transform.sax.SAXSource;//#GEN#[16]#PJ#
import javax.xml.transform.dom.DOMSource;//#GEN#[17]#PJ#
import org.xml.sax.SAXException;//#GEN#[18]#PJ#
import spec.benchmarks.xml.XMLBenchmark;//#GEN#[19]#PJ#
import spec.harness.Constants;//#GEN#[20]#PJ#
import spec.harness.Context;//#GEN#[21]#PJ#
import spec.harness.Launch;//#GEN#[22]#PJ#
import spec.harness.Util;//#GEN#[23]#PJ#
import spec.harness.results.BenchmarkResult;//#GEN#[24]#PJ#
import spec.io.FileCache;//#GEN#[25]#PJ#
import spec.io.FileCache.CachedFile;//#GEN#[26]#PJ#
import java.util.Properties;//#GEN#[27]#PJ#
//#GEN#[27]#PJ#
import pi.reductions.Reducible;//#GEN#[27]#PJ#
import java.util.*;//#GEN#[27]#PJ#
//#GEN#[27]#PJ#
public class Main extends XMLBenchmark {//#GEN#[29]#PJ#
    private static final int LONG_VALIDATION_MODE = 0;private static final int SHORT_VALIDATION_MODE = 1;private static final int SINGLE_LOOP_MODE = 0;private static final int MULTIPLE_LOOP_MODE = 1;private static final int INPUT_PAIR = 10;private static final String CONTROL_FILE_NAME = "transformations.properties";static String OUT_DIR = "xml_out";private static int THREADSNUM = 10;private static final String[] XML_NAMES = { "chess-fo/Kasparov-Karpov.xml", "jenitennison/index.xml", "jenitennison/text.xml", "nitf/nitf-fishing.xml", "shared/REC-xml-19980210.xml", "recipes/recipes.xml", "dsd/article.xml", "renderx/chess/Kasparov-Karpov.xml", "renderx/examples/balance/balance_sheet.xml", "renderx/examples/meeting/meeting_minutes.xml" };private static final String[] XSL_NAMES = { "chess-fo/chess.xsl", "jenitennison/page.xsl", "jenitennison/markup.xsl", "nitf/nitf-stylized.xsl", "spec-html/xmlspec.xsl", "recipes/recipes.xsl", "dsd/article2html.xsl", "renderx/chess/chess.xsl", "renderx/examples/balance/balance_sheet.xsl", "renderx/examples/meeting/meeting_minutes.xsl" };private static final int[] loops = { 2, 18, 31, 34, 1, 10, 12, 3, 11, 23 };private static FileCache.CachedFile[] xmlInput;private static FileCache.CachedFile[] xslInput;private static int validationMode = LONG_VALIDATION_MODE;private static int loopMode = SINGLE_LOOP_MODE;private static Properties longValidationProperties;private static Properties[][][] shortValidationProperties;private static String validationFileName;private static Transformer[][] allTransformers;private int threadId;private static void setValidationMode(int mode) {{//#GEN#[50]#PJ#
        validationMode = mode;//#GEN#[51]#PJ#
    }
    }
    static private ArrayList<ParIterator<?>> _omp_piVarContainer = new ArrayList<ParIterator<?>>();//#GEN#[-1]#PJ#
static private AtomicBoolean _holderForPIFirst= new AtomicBoolean(false);//#GEN#[-1]#PJ#

    private static int getValidationMode() {{//#GEN#[53]#PJ#
        return validationMode;//#GEN#[54]#PJ#
    }
    }
    
    private static void setLoopMode(int mode) {{//#GEN#[56]#PJ#
        loopMode = mode;//#GEN#[57]#PJ#
    }
    }
    
    private static int getLoopMode() {{//#GEN#[59]#PJ#
        return loopMode;//#GEN#[60]#PJ#
    }
    }
    
    public static String testType() {{//#GEN#[62]#PJ#
        return MULTI;//#GEN#[63]#PJ#
    }
    }
    
    public static void setupBenchmark() {{//#GEN#[65]#PJ#
        String tmpName = Util.getProperty(Constants.XML_TRANSFORM_OUT_DIR_PROP, null);//#GEN#[66]#PJ#
        OUT_DIR = tmpName != null ? tmpName : OUT_DIR;//#GEN#[67]#PJ#
        File file = new File(OUT_DIR);//#GEN#[68]#PJ#
        validationFileName = getFullName(Main.class, null, CONTROL_FILE_NAME);//#GEN#[69]#PJ#
        xmlInput = new FileCache.CachedFile[INPUT_PAIR];//#GEN#[70]#PJ#
        xslInput = new FileCache.CachedFile[INPUT_PAIR];//#GEN#[71]#PJ#
        for (int i = 0; i < INPUT_PAIR; i++) //#GEN#[72]#PJ#
        {//#GEN#[72]#PJ#
            xmlInput[i] = getCachedFile(Main.class, null, XML_NAMES[i]);//#GEN#[73]#PJ#
            xslInput[i] = getCachedFile(Main.class, null, XSL_NAMES[i]);//#GEN#[74]#PJ#
        }//#GEN#[75]#PJ#
        longValidationProperties = new Properties();//#GEN#[76]#PJ#
        try {//#GEN#[77]#PJ#
            if (!file.exists()) //#GEN#[78]#PJ#
            {//#GEN#[78]#PJ#
                file.mkdir();//#GEN#[79]#PJ#
            }//#GEN#[80]#PJ#
            longValidationProperties.load(new FileInputStream(validationFileName));//#GEN#[81]#PJ#
        } catch (IOException e) {//#GEN#[82]#PJ#
            e.printStackTrace();//#GEN#[83]#PJ#
        }//#GEN#[84]#PJ#
        setupTransformers();//#GEN#[85]#PJ#
        setValidationMode(LONG_VALIDATION_MODE);//#GEN#[86]#PJ#
        setLoopMode(SINGLE_LOOP_MODE);//#GEN#[87]#PJ#
        shortValidationProperties = new Properties[Launch.currentNumberBmThreads][THREADSNUM][3];//#GEN#[88]#PJ#
        Main main = new Main(new BenchmarkResult(), 1);//#GEN#[89]#PJ#
        main.harnessMain();//#GEN#[90]#PJ#
        int threads = Launch.currentNumberBmThreads;//#GEN#[91]#PJ#
        setValidationMode(SHORT_VALIDATION_MODE);//#GEN#[92]#PJ#
        setLoopMode(MULTIPLE_LOOP_MODE);//#GEN#[93]#PJ#
    }
    }
    
    public static void tearDownBenchmark() {{//#GEN#[95]#PJ#
        if (!ExtOutputStream.wasFullVerificationError && !Util.getBoolProperty(Constants.XML_TRANSFORM_LEAVE_OUT_DIR_PROP, null)) //#GEN#[96]#PJ#
        {//#GEN#[96]#PJ#
            remove(new File(OUT_DIR));//#GEN#[97]#PJ#
        }//#GEN#[98]#PJ#
    }
    }
    
    private static void setupTransformers() {{//#GEN#[100]#PJ#
        allTransformers = new Transformer[Launch.currentNumberBmThreads][INPUT_PAIR];//#GEN#[101]#PJ#
        try {//#GEN#[102]#PJ#
            TransformerFactory transformerFactory = TransformerFactory.newInstance();//#GEN#[103]#PJ#
            for (int i = 0; i < INPUT_PAIR; i++) //#GEN#[104]#PJ#
            {//#GEN#[104]#PJ#
                Templates precompiledTemplates = transformerFactory.newTemplates(xslInput[i].asNewStreamSource());//#GEN#[105]#PJ#
                for (int j = 0; j < Launch.currentNumberBmThreads; j++) //#GEN#[106]#PJ#
                {//#GEN#[106]#PJ#
                    allTransformers[j][i] = precompiledTemplates.newTransformer();//#GEN#[107]#PJ#
                }//#GEN#[108]#PJ#
            }//#GEN#[109]#PJ#
        } catch (TransformerConfigurationException e) {//#GEN#[110]#PJ#
            e.printStackTrace();//#GEN#[111]#PJ#
        } catch (IOException e) {//#GEN#[112]#PJ#
            e.printStackTrace();//#GEN#[113]#PJ#
        }//#GEN#[114]#PJ#
    }
    }
    
    private Transformer[] precompiledTransformers;private StreamResult streamResult;public Main(BenchmarkResult bmResult, int threadId) {//#GEN#[118]#PJ#
        super(bmResult, threadId);//#GEN#[119]#PJ#
        this.threadId = threadId;//#GEN#[120]#PJ#
        precompiledTransformers = allTransformers[threadId - 1];//#GEN#[121]#PJ#
    }public void harnessMain() {{//#GEN#[123]#PJ#
        try {//#GEN#[124]#PJ#
            for (int i = 0; i < 3; i++) //#GEN#[125]#PJ#
            {//#GEN#[125]#PJ#
                executeWorkload();//#GEN#[126]#PJ#
            }//#GEN#[127]#PJ#
        } catch (Exception e) {//#GEN#[128]#PJ#
            e.printStackTrace(Context.getOut());//#GEN#[129]#PJ#
        }//#GEN#[130]#PJ#
    }
    }
    
    public static void main(String[] args) throws Exception {
    Pyjama.init();//#GEN#[131]#PJ#
    {//#GEN#[132]#PJ#
        long start = System.currentTimeMillis();//#GEN#[133]#PJ#
        runSimple(Main.class, args);//#GEN#[134]#PJ#
        long time = System.currentTimeMillis() - start;//#GEN#[135]#PJ#
        System.out.println("PJ Parallel xml transform has taken  " + (time / 1000.0) + " seconds.");//#GEN#[136]#PJ#
    }
    }
    
    private Properties getOutProperties(BaseOutputStream outputStream) {{//#GEN#[138]#PJ#
        if (outputStream instanceof ExtOutputStream) //#GEN#[139]#PJ#
        {//#GEN#[139]#PJ#
            return ((ExtOutputStream) outputStream).getOutProperties();//#GEN#[140]#PJ#
        }//#GEN#[141]#PJ#
        return null;//#GEN#[142]#PJ#
    }
    }
    
    private void executeWorkload() throws TransformerException, ParserConfigurationException, SAXException, IOException {{//#GEN#[144]#PJ#
        /*OpenMP Parallel region (#0) -- START *///#GEN#[145]#PJ#
        if(Pyjama.insideParallelRegion() ) {//#GEN#[145]#PJ#
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) *///#GEN#[145]#PJ#
            {//#GEN#[146]#PJ#
                for (int i = 0; i < INPUT_PAIR; i = i+1) //#GEN#[148]#PJ#
                {//#GEN#[148]#PJ#
                    String propertyNamePrefix = XML_NAMES[i] + ".";//#GEN#[149]#PJ#
                    int loops = (getLoopMode() == SINGLE_LOOP_MODE) ? 1 : Main.loops[i];//#GEN#[150]#PJ#
                    Transformer transformer = precompiledTransformers[i];//#GEN#[151]#PJ#
                    try {//#GEN#[152]#PJ#
                        doTransform(loops, xmlInput[i], transformer, propertyNamePrefix, i);//#GEN#[153]#PJ#
                    } catch (SAXException e) {//#GEN#[154]#PJ#
                        e.printStackTrace(Context.getOut());//#GEN#[155]#PJ#
                    } catch (IOException e) {//#GEN#[156]#PJ#
                        e.printStackTrace(Context.getOut());//#GEN#[157]#PJ#
                    } catch (Exception e) {//#GEN#[158]#PJ#
                        e.printStackTrace(Context.getOut());//#GEN#[159]#PJ#
                    }//#GEN#[160]#PJ#
                }//#GEN#[161]#PJ#
            }//#GEN#[162]#PJ#
        } else {//#GEN#[145]#PJ#
            /* Else, execute in parallel *///#GEN#[145]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());//#GEN#[145]#PJ#
//#GEN#[145]#PJ#
            /* Process data clauses *///#GEN#[145]#PJ#
            _omp__parallelRegionVarHolderClass_Main0 _omp__parallelRegionVarHolderInstance_0 = new _omp__parallelRegionVarHolderClass_Main0();//#GEN#[145]#PJ#
//#GEN#[145]#PJ#
            /* Execute using traditional OpenMP (master thread part of the team) *///#GEN#[145]#PJ#
            PJPackageOnly.setMasterThread(Thread.currentThread());//#GEN#[145]#PJ#
            TaskID _omp__parallelRegionTaskID_0 = _ompParallelRegion_0(_omp__parallelRegionVarHolderInstance_0);//#GEN#[145]#PJ#
            __pt___ompParallelRegion_0(_omp__parallelRegionVarHolderInstance_0);//#GEN#[145]#PJ#
            try {_omp__parallelRegionTaskID_0.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }//#GEN#[145]#PJ#
            //#GEN#[145]#PJ#
            PJPackageOnly.setMasterThread(null);//#GEN#[145]#PJ#
            _holderForPIFirst.set(true);//#GEN#[145]#PJ#
//#GEN#[145]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);//#GEN#[145]#PJ#
        }//#GEN#[145]#PJ#
        /*OpenMP Parallel region (#0) -- END *///#GEN#[145]#PJ#
//#GEN#[145]#PJ#
    }
    }
        private AtomicBoolean _imFirst_2 = new AtomicBoolean(true);//#GEN#[-1]#PJ#
    private AtomicInteger _imFinishedCounter_2 = new AtomicInteger(0);//#GEN#[-1]#PJ#
    private CountDownLatch _waitBarrier_2 = new CountDownLatch(1);//#GEN#[-1]#PJ#
    private CountDownLatch _waitBarrierAfter_2 = new CountDownLatch(1);//#GEN#[-1]#PJ#
    private ParIterator<Integer> _pi_2 = null;//#GEN#[-1]#PJ#
    private Integer _lastElement_2 = null;//#GEN#[-1]#PJ#
    private _ompWorkSharedUserCode_Main2_variables _ompWorkSharedUserCode_Main2_variables_instance = null;//#GEN#[-1]#PJ#
        private void _ompWorkSharedUserCode_Main2(_ompWorkSharedUserCode_Main2_variables __omp_vars) {//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
        Integer i;//#GEN#[-1]#PJ#
        while (_pi_2.hasNext()) {//#GEN#[-1]#PJ#
            i = _pi_2.next();//#GEN#[-1]#PJ#
            //#GEN#[-1]#PJ#
            {//#GEN#[148]#PJ#
                String propertyNamePrefix = XML_NAMES[i] + ".";//#GEN#[149]#PJ#
                int loops = (getLoopMode() == SINGLE_LOOP_MODE) ? 1 : Main.loops[i];//#GEN#[150]#PJ#
                Transformer transformer = precompiledTransformers[i];//#GEN#[151]#PJ#
                try {//#GEN#[152]#PJ#
                    doTransform(loops, xmlInput[i], transformer, propertyNamePrefix, i);//#GEN#[153]#PJ#
                } catch (SAXException e) {//#GEN#[154]#PJ#
                    e.printStackTrace(Context.getOut());//#GEN#[155]#PJ#
                } catch (IOException e) {//#GEN#[156]#PJ#
                    e.printStackTrace(Context.getOut());//#GEN#[157]#PJ#
                } catch (Exception e) {//#GEN#[158]#PJ#
                    e.printStackTrace(Context.getOut());//#GEN#[159]#PJ#
                }//#GEN#[160]#PJ#
            }//#GEN#[-1]#PJ#
        }//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
    }//#GEN#[-1]#PJ#
    //#GEN#[-1]#PJ#
    //#GEN#[-1]#PJ#
    /* Parallel region, placed in a multi-task *///#GEN#[-1]#PJ#
    TASK(Pyjama.omp_get_num_threads()-1) private void _ompParallelRegion_0(_omp__parallelRegionVarHolderClass_Main0 __omp_vars) {//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
        {//#GEN#[146]#PJ#
            if ( Pyjama.insideParallelRegion() ) {//#GEN#[147]#PJ#
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) *///#GEN#[147]#PJ#
                boolean _omp_imFirst = _imFirst_2.getAndSet(false);//#GEN#[147]#PJ#
                _holderForPIFirst = _imFirst_2;//#GEN#[147]#PJ#
                if (_omp_imFirst) {//#GEN#[147]#PJ#
                    _ompWorkSharedUserCode_Main2_variables_instance = new _ompWorkSharedUserCode_Main2_variables();//#GEN#[147]#PJ#
                    int __omp_size_ = 0;//#GEN#[147]#PJ#
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping//#GEN#[147]#PJ#
                    for (int i = 0; i < INPUT_PAIR; i = i+1) {//#GEN#[147]#PJ#
                        _lastElement_2 = i;//#GEN#[147]#PJ#
                        __omp_size_++;//#GEN#[147]#PJ#
                        }//#GEN#[147]#PJ#
                    _pi_2 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.GUIDED, ParIterator.DEFAULT_CHUNKSIZE, false);//#GEN#[147]#PJ#
                    _omp_piVarContainer.add(_pi_2); // for interrupt statement//#GEN#[147]#PJ#
                    _pi_2.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[147]#PJ#
                    _waitBarrier_2.countDown();//#GEN#[147]#PJ#
                } else {//#GEN#[147]#PJ#
                    try { _waitBarrier_2.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }//#GEN#[147]#PJ#
                }//#GEN#[147]#PJ#
                _ompWorkSharedUserCode_Main2(_ompWorkSharedUserCode_Main2_variables_instance);//#GEN#[147]#PJ#
                if (_imFinishedCounter_2.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {//#GEN#[147]#PJ#
                    _waitBarrierAfter_2.countDown();//#GEN#[147]#PJ#
                } else {//#GEN#[147]#PJ#
                    try { //#GEN#[147]#PJ#
                        _waitBarrierAfter_2.await();//#GEN#[147]#PJ#
                    } catch (InterruptedException __omp__ie) { //#GEN#[147]#PJ#
                        __omp__ie.printStackTrace(); //#GEN#[147]#PJ#
                    }//#GEN#[147]#PJ#
                }//#GEN#[147]#PJ#
//#GEN#[147]#PJ#
            } else {//#GEN#[147]#PJ#
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially *///#GEN#[147]#PJ#
                for (int i = 0; i < INPUT_PAIR; i = i+1) //#GEN#[148]#PJ#
                {//#GEN#[148]#PJ#
                    String propertyNamePrefix = XML_NAMES[i] + ".";//#GEN#[149]#PJ#
                    int loops = (getLoopMode() == SINGLE_LOOP_MODE) ? 1 : Main.loops[i];//#GEN#[150]#PJ#
                    Transformer transformer = precompiledTransformers[i];//#GEN#[151]#PJ#
                    try {//#GEN#[152]#PJ#
                        doTransform(loops, xmlInput[i], transformer, propertyNamePrefix, i);//#GEN#[153]#PJ#
                    } catch (SAXException e) {//#GEN#[154]#PJ#
                        e.printStackTrace(Context.getOut());//#GEN#[155]#PJ#
                    } catch (IOException e) {//#GEN#[156]#PJ#
                        e.printStackTrace(Context.getOut());//#GEN#[157]#PJ#
                    } catch (Exception e) {//#GEN#[158]#PJ#
                        e.printStackTrace(Context.getOut());//#GEN#[159]#PJ#
                    }//#GEN#[160]#PJ#
                }//#GEN#[161]#PJ#
            }//#GEN#[161]#PJ#
//#GEN#[161]#PJ#
        }//#GEN#[162]#PJ#
//#GEN#[162]#PJ#
    }
    private void doTransform(int loops, CachedFile xmlInput, Transformer transformer, String propertyNamePrefix, int INPUT_PAIR_num) throws TransformerException, ParserConfigurationException, SAXException, IOException {{//#GEN#[164]#PJ#
        for (int j = loops - 1; j >= 0; j--) //#GEN#[165]#PJ#
        {//#GEN#[165]#PJ#
            transform(transformer, createSaxSource(xmlInput), propertyNamePrefix + "SAX", j, INPUT_PAIR_num);//#GEN#[166]#PJ#
            transform(transformer, createDomSource(xmlInput), propertyNamePrefix + "DOM", j, INPUT_PAIR_num);//#GEN#[167]#PJ#
            transform(transformer, xmlInput.asNewStreamSource(), propertyNamePrefix + "Stream", j, INPUT_PAIR_num);//#GEN#[168]#PJ#
        }//#GEN#[169]#PJ#
    }
    }
    
    private void transform(Transformer transformer, Source source, String descr, int loop, int INPUT_PAIR_num) throws TransformerException, ParserConfigurationException, SAXException, IOException {{//#GEN#[171]#PJ#
        transformer.reset();//#GEN#[172]#PJ#
        BaseOutputStream outputStream;//#GEN#[173]#PJ#
        StreamResult streamResult;//#GEN#[174]#PJ#
        int sourceType = source instanceof SAXSource ? 0 : (source instanceof DOMSource ? 1 : 2);//#GEN#[175]#PJ#
        if (getValidationMode() == LONG_VALIDATION_MODE) //#GEN#[176]#PJ#
        {//#GEN#[176]#PJ#
            outputStream = new ExtOutputStream();//#GEN#[177]#PJ#
            streamResult = new StreamResult(outputStream);//#GEN#[178]#PJ#
            outputStream.setValidationProperties(longValidationProperties);//#GEN#[179]#PJ#
        } else {//#GEN#[180]#PJ#
            outputStream = new BaseOutputStream();//#GEN#[181]#PJ#
            streamResult = new StreamResult(outputStream);//#GEN#[182]#PJ#
            outputStream.setValidationProperties(shortValidationProperties[threadId - 1][INPUT_PAIR_num][sourceType]);//#GEN#[183]#PJ#
        }//#GEN#[184]#PJ#
        outputStream.setCurrentProp(descr);//#GEN#[185]#PJ#
        transformer.transform(source, streamResult);//#GEN#[186]#PJ#
        outputStream.checkResult(loop);//#GEN#[187]#PJ#
        if ((getValidationMode() == LONG_VALIDATION_MODE) && (outputStream instanceof ExtOutputStream)) //#GEN#[188]#PJ#
        {//#GEN#[188]#PJ#
            int threads = Launch.currentNumberBmThreads;//#GEN#[189]#PJ#
            Properties outProperties = getOutProperties(outputStream);//#GEN#[190]#PJ#
            for (int i = 0; i < threads; i++) //#GEN#[191]#PJ#
            {//#GEN#[191]#PJ#
                shortValidationProperties[i][INPUT_PAIR_num][sourceType] = (Properties) outProperties.clone();//#GEN#[192]#PJ#
            }//#GEN#[193]#PJ#
        }//#GEN#[194]#PJ#
    }
    }
    
}//#GEN#[195]#PJ#
